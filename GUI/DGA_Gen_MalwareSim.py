import random
import argparse
from datetime import datetime
import sys
import time
import hashlib
import pandas as pd
from scapy.layers.inet import IP, ICMP, icmpcodes, icmptypes
from scapy.all import *
import subprocess

norm_domains = pd.read_csv('../../DGA datasets/majestic_million_csv.csv', usecols=["Domain"])

banjori_seeds = [
    # Seeds from https://blog.kleissner.org/?p=69
    "xxxxedsafe.com",
    "xxxxhuxmiax.com",
    "xxxxierihon.com",
    "xxxxtomvader.com",
    "xxxxednog.com",
    "xxxxapontis.com",
    "xxxxefnomosk.com",
    "xxxxdminmont.com",
    "xxxxesroater.com",
    "xxxxggelds.com",
    "xxxxmobama.com",
    # Seeds from https://www.johannesbader.ch/2015/02/the-dga-of-banjori/
    "antisemitismgavenuteq.com",
    "bandepictom.com",
    "buckbyplaywobb.com",
    "telemachuslazaroqok.com",
    "texanfoulilp.com",
    "clearasildeafeninguvuc.com",
    "marisagabardinedazyx.com",
    "pickfordlinnetavox.com",
    "snapplefrostbitecycz.com",
    "filtererwyatanb.com",
    "antwancorml.com",
    "stravinskycattederifg.com",
    "forepartbulkyf.com",
    "fundamentalistfanchonut.com",
    "criterionirkutskagl.com",
    "criminalcentricem.com",
    "babysatformalisticirekb.com",
    "earnestnessbiophysicalohax.com",
    # Seeds from https://blog.kleissner.org/?p=192
    "displeasuredehydratorysagp.com",
    "antisemitismgavenuteq.com",
    "cantorcajanunal.com",
    "andersensinaix.com",
    "formidablyhoosieraw.com",
    "gbpsenhancedysb.com",
    "genialitydevonianizuwb.com",
    "gerhardenslavetusul.com",
    "kennanerraticallyqozaw.com",
    "rozellaabettingk.com",
    "doniellefrictionlessv.com",
    "anshanarianaqh.com",
    "buckbyplaywobb.com"
]

padcrypt_configs = {
    "2.2.86.1" : {
        'nr_domains': 24,
        'tlds': ['com', 'co.uk', 'de', 'org', 'net', 'eu', 'info', 'online',
            'co', 'cc', 'website'],
        'digit_mapping': "abcdnfolmk",
        'separator': ':',
        },
    "2.2.97.0" : {
        'nr_domains': 24*3,
        'tlds': ['com', 'co.uk', 'de', 'org', 'net', 'eu', 'info', 'online',
            'co', 'cc', 'website'],
        'digit_mapping': "abcdnfolmk",
        'separator': '|'
        }
}

tinba_dga_configurations = {
    0: { # http://garage4hackers.com/entry.php?b=3086
        'seed': 'oGkS3w3sGGOGG7oc', 
        'domain': 'ssrgwnrmgrxe.com',
        'tlds': ['com']
    },
    1: { # https://johannesbader.ch/2015/04/new-top-level-domains-for-tinbas-dga
        'seed': 'jc74FlUna852Ji9o', 
        'domain': 'blackfreeqazyio.cc',
        'tlds': ['com', 'net', 'in', 'ru']
    },
    2: { # https://www.sophos.com/en-us/threat-center/threat-analyses/viruses-and-spyware/Troj~Tinba-EL/detailed-analysis.aspx
         # https://github.com/baderj/domain_generation_algorithms/commit/c7d154a39bb172c4632f7565e0c9380e8b36c18e
        'seed': 'yqokqFC2TPBFfJcG', 
        'domain': 'watchthisnow.xyz',
        'tlds': ['pw', 'us', 'xyz', 'club']
    },
    3: {# https://github.com/baderj/domain_generation_algorithms/commit/c7d154a39bb172c4632f7565e0c9380e8b36c18e
        'seed': 'j193HsnW72Yqns7u', 
        'domain': 'j193hsne720uie8i.cc',
        'tlds': ['com', 'net', 'biz', 'org']
    }
}

def strTimeProp(start, end, format, prop):
    """Get a time at a proportion of a range of two formatted times.
    start and end should be strings specifying times formated in the
    given format (strftime-style), giving an interval [start, end].
    prop specifies how a proportion of the interval to be taken after
    start.  The returned time will be in the specified format.
    """

    stime = time.mktime(time.strptime(start, format))
    etime = time.mktime(time.strptime(end, format))

    ptime = stime + prop * (etime - stime)

    return time.strftime(format, time.localtime(ptime))
  
def randomDate(start, end, prop):
    return strTimeProp(start, end, '%m/%d/%Y %I:%M %p', prop)

def map_to_lowercase_letter(s):
    return ord('a') + ((s - ord('a')) % 26)

def next_domain(domain):
    dl = [ord(x) for x in list(domain)]
    dl[0] = map_to_lowercase_letter(dl[0] + dl[3])
    dl[1] = map_to_lowercase_letter(dl[0] + 2*dl[1])
    dl[2] = map_to_lowercase_letter(dl[0] + dl[2] - 1)
    dl[3] = map_to_lowercase_letter(dl[1] + dl[2] + dl[3])
    return ''.join([chr(x) for x in dl])

def banjori():
    domain = random.choice(banjori_seeds)
    domain = next_domain(domain)
    print(domain)
    return domain

def generate_necurs_domain(sequence_nr, magic_nr, date):
    def pseudo_random(value):
        loops = (value & 0x7F) + 21
        for index in range(loops):
            value += ((value*7) ^ (value << 15)) + 8*index - (value >> 5)
            value &= ((1 << 64) - 1)

        return value

    def mod64(nr1, nr2):
        return nr1 % nr2

    n = pseudo_random(date.year)
    n = pseudo_random(n + date.month + 43690)
    n = pseudo_random(n + (date.day>>2))
    n = pseudo_random(n + sequence_nr)
    n = pseudo_random(n + magic_nr)
    domain_length = mod64(n, 15) + 7

    domain = ""
    for i in range(domain_length):
        n = pseudo_random(n+i) 
        ch = mod64(n, 25) + ord('a') 
        domain += chr(ch)
        n += 0xABBEDF
        n = pseudo_random(n) 

    tlds = ['tj','in','jp','tw','ac','cm','la','mn','so','sh','sc','nu','nf','mu',
    'ms','mx','ki','im','cx','cc','tv','bz','me','eu','de','ru','co','su','pw',
    'kz','sx','us','ug','ir','to','ga','com','net','org','biz','xxx','pro'
    #,'bit' Removed due to Apache DomainValidator Filter.
    ]

    tld = tlds[mod64(n, len(tlds))]
    domain += '.' + tld
    return domain
    


def necurs():
    date = randomDate("1/1/1980 01:00 AM", "1/1/3000 1:10 AM", random.random())
    d = datetime.strptime(date, "%m/%d/%Y %I:%M %p")
    magic_number = random.randint(1, sys.maxsize)    
    domain = generate_necurs_domain(0, magic_number, d)
    print(domain)
    return domain

def padcrypt_dga(date, config_nr):
    config = padcrypt_configs[config_nr]
    dm = config['digit_mapping']
    tlds = config['tlds']
    for i in range(config['nr_domains']):
        seed_str = "{}-{}-{}{}{}".format(date.day, date.month, date.year,
                config['separator'], i)
        h = hashlib.sha256(seed_str.encode('ascii')).hexdigest()
        domain = ""
        for hh in h[3:16+3]:
            domain += dm[int(hh)] if '0' <= hh <= '9' else hh
        tld_index = int(h[-1], 16)
        tld_index = 0 if tld_index >= len(tlds) else tld_index
        domain += "." + config['tlds'][tld_index]
        yield domain
        break
    
def padcrypt():
    date = randomDate("1/1/1980 01:00 AM", "1/1/3000 1:10 AM", random.random())
    d = datetime.strptime(date, "%m/%d/%Y %I:%M %p")
    for domain in padcrypt_dga(d,"2.2.97.0"): 
        print(domain)
    return(domain)

def murofet_dga(date):
    for index in range(1020):
        seed = 7*[0]
        seed[0] = ((date.year & 0xFF) + 0x30) & 0xFF
        seed[1] = date.month 
        seed[2] = (date.day//7)*7
        r = index
        for i in range(4):
            seed[3+i] = r & 0xFF
            r >>= 8

        seed_str = ""
        for i in range(7):
            seed_str += chr((seed[i]))

        m = hashlib.md5()
        m.update(seed_str.encode('utf-8'))
        md5 = m.digest()

        domain = ""
        for m in md5:
            d = (m & 0x1F) + ord('a')
            c = (m >> 3) + ord('a')
            if d != c:
                if d <= ord('z'):
                    domain += chr(d)
                if c <= ord('z'):
                    domain += chr(c)

        tlds = [".ru", ".biz", ".info", ".org", ".net", ".com"]
        for i, tld in enumerate(tlds): 
            m = len(tlds) - i
            if not index % m: 
                domain += tld
                break
        return domain

def murofet():
    date = randomDate("1/1/1980 01:00 AM", "1/1/3000 1:10 AM", random.random())
    d = datetime.strptime(date, "%m/%d/%Y %I:%M %p")
    domain = murofet_dga(d)
    print(domain)
    return domain

def tinba_dga(dga_config):
    dga_config['domain_l'] = [ord(l) for l in dga_config['domain']]
    dga_config['seed_sum'] = sum(dga_config['seed_l'][:16])
    new_domain = []
    tmp = dga_config['seed_l'][15] & 0xFF
    for i in range(12):
        while True:
            tmp += dga_config['domain_l'][i]
            tmp ^= (dga_config['seed_sum'] & 0xFF)
            tmp += dga_config['domain_l'][i+1]
            tmp &= 0xFF
            if 0x61 < tmp < 0x7a:
                new_domain.append(tmp)
                break
            else:
                dga_config['seed_sum'] += 1

    base_domain = ''.join([chr(x) for x in new_domain])
    #domains = []
    #for tld in dga_config['tlds']:
    #    dga_config['domain'] = base_domain + '.' + tld
    #    domains.append(dga_config['domain'])
    #return domains
    domain = base_domain + '.' + random.choice(dga_config['tlds'])
    dga_config['domain'] = domain
    return domain

def tinba():
    config = random.choice(tinba_dga_configurations)
    config['seed'] += (17 - len(config['seed']))*'\x00'
    config['seed_l'] = [ord(s) for s in config['seed']]

#for domain in dga(config):
    domain = tinba_dga(config)
    print(domain)
    return(domain)

def benign():
    domain = norm_domains.sample(1).values[0][0]
    print(domain)
    return domain

if __name__=="__main__":
    domain_fns = [
        banjori,
        necurs,
        padcrypt,
        murofet,
        tinba,
        benign,
        benign,
        benign,
        benign,
        benign,
        benign,
        benign,
        benign,
        benign]
    
    while(True):
        domain = random.choice(domain_fns)()
        try:
            subprocess.check_output(["ping", domain])
        except:
            pass
    
